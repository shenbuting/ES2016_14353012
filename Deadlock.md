# 死锁
## 产生死锁的4个必要条件
* 互斥条件：一个资源每次只能被一个进程使用  
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放  
* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺  
* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系

## 操作过程
> 随便找个地方放Deadlock.java，我的话在dol文件夹里新建了一个Deadlock文件夹来存放： 
![3.png](https://ooo.0o0.ooo/2016/11/11/582594a00c603.png)
![4.png](https://ooo.0o0.ooo/2016/11/11/582595220091d.png)

> 编译和运行：  
![1.png](https://ooo.0o0.ooo/2016/11/11/58259539e4b1a.png)
  
> windows系统下运行.bat文件:  
![6.png](https://ooo.0o0.ooo/2016/11/11/58259553d0255.png)
    
> 在虚拟机里可运行.sh文件：  
![5.png](https://ooo.0o0.ooo/2016/11/11/5825956f71eb0.png)
     
> 运行结果：  
![2.png](https://ooo.0o0.ooo/2016/11/11/5825958d12203.png) 

> 产生死锁的原因：  
> 用synchronized函数在A类中申请B锁，在B类中申请A锁，由于同步线程，有可能会出现先B再A和先A再B的情况，这是不会导致死锁的。当A恰好在申请B锁而B在申请A锁时，才会发生死锁现象，所以我们跑很多次，触发这个概率事件。